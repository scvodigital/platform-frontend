'use strict';

// In the absence of a WeakSet or WeakMap implementation, don't break, but don't cache either.
function noop() {}
function createWeakMap() {
    if (typeof WeakMap !== 'undefined') {
        return new WeakMap();
    } else {
        return fakeSetOrMap();
    }
}
function fakeSetOrMap() {
    return {
        add: noop,
        delete: noop,
        set: noop,
        has: function has() {
            return false;
        }
    };
}

// Safe hasOwnProperty
var hop = Object.prototype.hasOwnProperty;
var has = function has(obj, prop) {
    return hop.call(obj, prop);
};

// Copy all own enumerable properties from source to target
function extend(target, source) {
    for (var prop in source) {
        if (has(source, prop)) {
            target[prop] = source[prop];
        }
    }
    return target;
}

var reLeadingNewline = /^[ \t]*(?:\r\n|\r|\n)/;
var reTrailingNewline = /(?:\r\n|\r|\n)[ \t]*$/;
var reStartsWithNewlineOrIsEmpty = /^(?:[\r\n]|$)/;
var reDetectIndentation = /(\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/;
var reOnlyWhitespaceWithAtLeastOneNewline = /^[ \t]*[\r\n][ \t\r\n]*$/;

function _outdent(strings, values, outdentInstance, options) {
    // If first interpolated value is a reference to outdent,
    // determine indentation level from the indentation of the interpolated value.
    var indentationLevel = 0;

    var match = strings[0].match(reDetectIndentation);
    if (match) {
        indentationLevel = match[2].length;
    }

    var reSource = '(\\r\\n|\\r|\\n).{0,' + indentationLevel + '}';
    var reMatchIndent = new RegExp(reSource, 'g');

    // Is first interpolated value a reference to outdent, alone on its own line, without any preceding non-whitespace?
    if ((values[0] === outdentInstance || values[0] === outdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1])) {
        values = values.slice(1);
        strings = strings.slice(1);
    }

    var l = strings.length;
    var outdentedStrings = strings.map(function (v, i) {
        // Remove leading indentation from all lines
        v = v.replace(reMatchIndent, '$1');
        // Trim a leading newline from the first string
        if (i === 0 && options.trimLeadingNewline) {
            v = v.replace(reLeadingNewline, '');
        }
        // Trim a trailing newline from the last string
        if (i === l - 1 && options.trimTrailingNewline) {
            v = v.replace(reTrailingNewline, '');
        }
        return v;
    });

    return concatStringsAndValues(outdentedStrings, values);
}

function concatStringsAndValues(strings, values) {
    var ret = '';
    for (var i = 0, l = strings.length; i < l; i++) {
        ret += strings[i];
        if (i < l - 1) {
            ret += values[i];
        }
    }
    return ret;
}

/**
 * It is assumed that opts will not change.  If this is a problem, clone your options object and pass the clone to
 * makeInstance
 * @param options
 * @return {outdent}
 */
function createInstance(options) {
    var cache = createWeakMap();

    var ret = function outdent(stringsOrOptions) {
        if (has(stringsOrOptions, 'raw') && has(stringsOrOptions, 'length')) {
            // TODO Enable semi-caching, both when the first interpolated value is `outdent`, and when it's not
            var strings = stringsOrOptions;
            // Serve from cache only if there are no interpolated values

            for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                values[_key - 1] = arguments[_key];
            }

            if (values.length === 0 && cache.has(strings)) return cache.get(strings);

            // Perform outdentation
            var rendered = _outdent(strings, values, ret, options);

            // Store into the cache only if there are no interpolated values
            values.length === 0 && cache.set(strings, rendered);
            return rendered;
        } else {
            // Create and return a new instance of outdent with the given options
            return createInstance(extend(extend({}, options), stringsOrOptions || {}));
        }
    };

    return ret;
}

var outdent = createInstance({
    trimLeadingNewline: true,
    trimTrailingNewline: true
});

// ES6
outdent.default = outdent;
outdent.outdent = outdent;
outdent.__esModule = true;
exports.default = outdent;
exports.outdent = outdent;
exports.__esModule = true;
module.exports = outdent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5lcyJdLCJuYW1lcyI6WyJub29wIiwiY3JlYXRlV2Vha01hcCIsIldlYWtNYXAiLCJmYWtlU2V0T3JNYXAiLCJhZGQiLCJkZWxldGUiLCJzZXQiLCJoYXMiLCJob3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJjYWxsIiwiZXh0ZW5kIiwidGFyZ2V0Iiwic291cmNlIiwicmVMZWFkaW5nTmV3bGluZSIsInJlVHJhaWxpbmdOZXdsaW5lIiwicmVTdGFydHNXaXRoTmV3bGluZU9ySXNFbXB0eSIsInJlRGV0ZWN0SW5kZW50YXRpb24iLCJyZU9ubHlXaGl0ZXNwYWNlV2l0aEF0TGVhc3RPbmVOZXdsaW5lIiwiX291dGRlbnQiLCJzdHJpbmdzIiwidmFsdWVzIiwib3V0ZGVudEluc3RhbmNlIiwib3B0aW9ucyIsImluZGVudGF0aW9uTGV2ZWwiLCJtYXRjaCIsImxlbmd0aCIsInJlU291cmNlIiwicmVNYXRjaEluZGVudCIsIlJlZ0V4cCIsIm91dGRlbnQiLCJ0ZXN0Iiwic2xpY2UiLCJsIiwib3V0ZGVudGVkU3RyaW5ncyIsIm1hcCIsInYiLCJpIiwicmVwbGFjZSIsInRyaW1MZWFkaW5nTmV3bGluZSIsInRyaW1UcmFpbGluZ05ld2xpbmUiLCJjb25jYXRTdHJpbmdzQW5kVmFsdWVzIiwicmV0IiwiY3JlYXRlSW5zdGFuY2UiLCJjYWNoZSIsInN0cmluZ3NPck9wdGlvbnMiLCJnZXQiLCJyZW5kZXJlZCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiZXhwb3J0cyIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLFNBQVNBLElBQVQsR0FBZ0IsQ0FBRTtBQUNsQixTQUFTQyxhQUFULEdBQXlCO0FBQ3JCLFFBQUcsT0FBT0MsT0FBUCxLQUFtQixXQUF0QixFQUFtQztBQUMvQixlQUFPLElBQUlBLE9BQUosRUFBUDtBQUNILEtBRkQsTUFFTztBQUNILGVBQU9DLGNBQVA7QUFD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SDs7QUFFRCxJQUFNWixVQUFVYSxlQUFlO0FBQzNCSix3QkFBb0IsSUFETztBQUUzQkMseUJBQXFCO0FBRk0sQ0FBZixDQUFoQjs7QUFLQTtBQUNBVixRQUFRa0IsT0FBUixHQUFrQmxCLE9BQWxCO0FBQ0FBLFFBQVFBLE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0FBLFFBQVFtQixVQUFSLEdBQXFCLElBQXJCO0FBQ0FDLFFBQVFGLE9BQVIsR0FBa0JsQixPQUFsQjtBQUNBb0IsUUFBUXBCLE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0FvQixRQUFRRCxVQUFSLEdBQXFCLElBQXJCO0FBQ0FFLE9BQU9ELE9BQVAsR0FBaUJwQixPQUFqQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEluIHRoZSBhYnNlbmNlIG9mIGEgV2Vha1NldCBvciBXZWFrTWFwIGltcGxlbWVudGF0aW9uLCBkb24ndCBicmVhaywgYnV0IGRvbid0IGNhY2hlIGVpdGhlci5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gY3JlYXRlV2Vha01hcCgpIHtcbiAgICBpZih0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWFrTWFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZha2VTZXRPck1hcCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZha2VTZXRPck1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IG5vb3AsXG4gICAgICAgIGRlbGV0ZTogbm9vcCxcbiAgICAgICAgc2V0OiBub29wLFxuICAgICAgICBoYXM6IGZ1bmN0aW9uKCkge3JldHVybiBmYWxzZTt9XG4gICAgfTtcbn1cblxuLy8gU2FmZSBoYXNPd25Qcm9wZXJ0eVxuY29uc3QgaG9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhcyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBob3AuY2FsbChvYmosIHByb3ApO1xufTtcblxuLy8gQ29weSBhbGwgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0YXJnZXRcbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvcihsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYoaGFzKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCByZUxlYWRpbmdOZXdsaW5lID0gL15bIFxcdF0qKD86XFxyXFxufFxccnxcXG4pLztcbmNvbnN0IHJlVHJhaWxpbmdOZXdsaW5lID0gLyg/OlxcclxcbnxcXHJ8XFxuKVsgXFx0XSokLztcbmNvbnN0IHJlU3RhcnRzV2l0aE5ld2xpbmVPcklzRW1wdHkgPSAvXig/OltcXHJcXG5dfCQpLztcbmNvbnN0IHJlRGV0ZWN0SW5kZW50YXRpb24gPSAvKFxcclxcbnxcXHJ8XFxuKShbIFxcdF0qKSg/OlteIFxcdFxcclxcbl18JCkvO1xuY29uc3QgcmVPbmx5V2hpdGVzcGFjZVdpdGhBdExlYXN0T25lTmV3bGluZSA9IC9eWyBcXHRdKltcXHJcXG5dWyBcXHRcXHJcXG5dKiQvO1xuXG5mdW5jdGlvbiBfb3V0ZGVudChzdHJpbmdzLCB2YWx1ZXMsIG91dGRlbnRJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIC8vIElmIGZpcnN0IGludGVycG9sYXRlZCB2YWx1ZSBpcyBhIHJlZmVyZW5jZSB0byBvdXRkZW50LFxuICAgIC8vIGRldGVybWluZSBpbmRlbnRhdGlvbiBsZXZlbCBmcm9tIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICAgIGxldCBpbmRlbnRhdGlvbkxldmVsID0gMDtcblxuICAgIGNvbnN0IG1hdGNoID0gc3RyaW5nc1swXS5tYXRjaChyZURldGVjdEluZGVudGF0aW9uKTtcbiAgICBpZihtYXRjaCkge1xuICAgICAgICBpbmRlbnRhdGlvbkxldmVsID0gbWF0Y2hbMl0ubGVuZ3RoO1xuICAgIH1cblxuICAgIGxldCByZVNvdXJjZSA9IGAoXFxcXHJcXFxcbnxcXFxccnxcXFxcbikuezAsJHtpbmRlbnRhdGlvbkxldmVsfX1gO1xuICAgIGNvbnN0IHJlTWF0Y2hJbmRlbnQgPSBuZXcgUmVnRXhwKHJlU291cmNlLCAnZycpO1xuXG4gICAgLy8gSXMgZmlyc3QgaW50ZXJwb2xhdGVkIHZhbHVlIGEgcmVmZXJlbmNlIHRvIG91dGRlbnQsIGFsb25lIG9uIGl0cyBvd24gbGluZSwgd2l0aG91dCBhbnkgcHJlY2VkaW5nIG5vbi13aGl0ZXNwYWNlP1xuICAgIGlmKFxuICAgICAgICAodmFsdWVzWzBdID09PSBvdXRkZW50SW5zdGFuY2UgfHwgdmFsdWVzWzBdID09PSBvdXRkZW50KSAmJlxuICAgICAgICByZU9ubHlXaGl0ZXNwYWNlV2l0aEF0TGVhc3RPbmVOZXdsaW5lLnRlc3Qoc3RyaW5nc1swXSkgJiZcbiAgICAgICAgcmVTdGFydHNXaXRoTmV3bGluZU9ySXNFbXB0eS50ZXN0KHN0cmluZ3NbMV0pXG4gICAgKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgc3RyaW5ncyA9IHN0cmluZ3Muc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgY29uc3QgbCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgIGNvbnN0IG91dGRlbnRlZFN0cmluZ3MgPSBzdHJpbmdzLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBpbmRlbnRhdGlvbiBmcm9tIGFsbCBsaW5lc1xuICAgICAgICB2ID0gdi5yZXBsYWNlKHJlTWF0Y2hJbmRlbnQsICckMScpO1xuICAgICAgICAvLyBUcmltIGEgbGVhZGluZyBuZXdsaW5lIGZyb20gdGhlIGZpcnN0IHN0cmluZ1xuICAgICAgICBpZihpID09PSAwICYmIG9wdGlvbnMudHJpbUxlYWRpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICB2ID0gdi5yZXBsYWNlKHJlTGVhZGluZ05ld2xpbmUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIGEgdHJhaWxpbmcgbmV3bGluZSBmcm9tIHRoZSBsYXN0IHN0cmluZ1xuICAgICAgICBpZihpID09PSBsIC0gMSAmJiBvcHRpb25zLnRyaW1UcmFpbGluZ05ld2xpbmUpIHtcbiAgICAgICAgICAgIHYgPSB2LnJlcGxhY2UocmVUcmFpbGluZ05ld2xpbmUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gY29uY2F0U3RyaW5nc0FuZFZhbHVlcyhvdXRkZW50ZWRTdHJpbmdzLCB2YWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBjb25jYXRTdHJpbmdzQW5kVmFsdWVzKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIGxldCByZXQgPSAnJztcbiAgICBmb3IobGV0IGkgPSAwLCBsID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmV0ICs9IHN0cmluZ3NbaV07XG4gICAgICAgIGlmKGkgPCBsIC0gMSkge1xuICAgICAgICAgICAgcmV0ICs9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCBvcHRzIHdpbGwgbm90IGNoYW5nZS4gIElmIHRoaXMgaXMgYSBwcm9ibGVtLCBjbG9uZSB5b3VyIG9wdGlvbnMgb2JqZWN0IGFuZCBwYXNzIHRoZSBjbG9uZSB0b1xuICogbWFrZUluc3RhbmNlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybiB7b3V0ZGVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IGNhY2hlID0gY3JlYXRlV2Vha01hcCgpO1xuXG4gICAgY29uc3QgcmV0ID0gZnVuY3Rpb24gb3V0ZGVudChzdHJpbmdzT3JPcHRpb25zLCAuLi52YWx1ZXMpIHtcbiAgICAgICAgaWYoaGFzKHN0cmluZ3NPck9wdGlvbnMsICdyYXcnKSAmJiBoYXMoc3RyaW5nc09yT3B0aW9ucywgJ2xlbmd0aCcpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIEVuYWJsZSBzZW1pLWNhY2hpbmcsIGJvdGggd2hlbiB0aGUgZmlyc3QgaW50ZXJwb2xhdGVkIHZhbHVlIGlzIGBvdXRkZW50YCwgYW5kIHdoZW4gaXQncyBub3RcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ3MgPSBzdHJpbmdzT3JPcHRpb25zO1xuICAgICAgICAgICAgLy8gU2VydmUgZnJvbSBjYWNoZSBvbmx5IGlmIHRoZXJlIGFyZSBubyBpbnRlcnBvbGF0ZWQgdmFsdWVzXG4gICAgICAgICAgICBpZih2YWx1ZXMubGVuZ3RoID09PSAwICYmIGNhY2hlLmhhcyhzdHJpbmdzKSkgcmV0dXJuIGNhY2hlLmdldChzdHJpbmdzKTtcblxuICAgICAgICAgICAgLy8gUGVyZm9ybSBvdXRkZW50YXRpb25cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkID0gX291dGRlbnQoc3RyaW5ncywgdmFsdWVzLCByZXQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBpbnRvIHRoZSBjYWNoZSBvbmx5IGlmIHRoZXJlIGFyZSBubyBpbnRlcnBvbGF0ZWQgdmFsdWVzXG4gICAgICAgICAgICB2YWx1ZXMubGVuZ3RoID09PSAwICYmIGNhY2hlLnNldChzdHJpbmdzLCByZW5kZXJlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBvdXRkZW50IHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShleHRlbmQoZXh0ZW5kKHt9LCBvcHRpb25zKSwgc3RyaW5nc09yT3B0aW9ucyB8fCB7fSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IG91dGRlbnQgPSBjcmVhdGVJbnN0YW5jZSh7XG4gICAgdHJpbUxlYWRpbmdOZXdsaW5lOiB0cnVlLFxuICAgIHRyaW1UcmFpbGluZ05ld2xpbmU6IHRydWVcbn0pO1xuXG4vLyBFUzZcbm91dGRlbnQuZGVmYXVsdCA9IG91dGRlbnQ7XG5vdXRkZW50Lm91dGRlbnQgPSBvdXRkZW50O1xub3V0ZGVudC5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG91dGRlbnQ7XG5leHBvcnRzLm91dGRlbnQgPSBvdXRkZW50O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbm1vZHVsZS5leHBvcnRzID0gb3V0ZGVudDtcbiJdfQ==